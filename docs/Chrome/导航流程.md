# 导航流程
> 用户发出url请求 到 页面开始解析 的这个过程 叫导航 \
> 思考：从输入url到页面展示，这中间发生了什么？

![导航流程](./res/导航流程.webp)

1. 浏览器进程接收到用户输入url (通过IPC通信)转发给 网络进程，发起请求
2. 网络进程收到响应头，转发给浏览器进程
3. 浏览器进程收到后，发送“提交导航”消息 到 渲染进程
4. 渲染进程收到消息后，开始准备接收数据，接收方式：直接和网络进程建立数据管道
5. 渲染进程向浏览器进程“确认提交”
6. 浏览器进程开始移除旧文档，更新页面状态

## 详细过程
- 用户输入
  - 判断是否符合url规则，不符合 则触发搜索引擎，搜索关键字
  - 回车后，浏览器提供  beforeunload 事件 允许用户 退出之前执行一些操作，或取消导航
  - 标签页的图标进入加载状态
    - 需要等到**提交文档阶段**, 页面内容才会替换
- 网络进程
  - 查找资源缓存
  - 发起请求
    - DNS解析
    - https 需要 建立TLS连接
    - TCP连接
    - 发送数据
  - 响应数据
    - 重定向（浏览器会跳转到新的地址继续导航；）
    - 200 继续处理请求
    - 响应数据类型 `Content-Type`
      - `text/html` HTML格式
        - 继续导航
      - `application/octet-stream` 字节流类型，下载类型
        - 导航结束
  - 准备渲染进程
    - 默认会为每个tab分配一个渲染进程
      - 如果从一个页面打开另一个页面，如果属于同一站点，则会复用父页面的渲染进程（process-per-site-instance策略）
      - **同一站点**：根域名相同
  - 提交文档（这就是为什么浏览器地址输入url后 之前页面没有立马消失，加载一会儿才更新页面）
    - 浏览器进程收到网络进程的响应头后，像渲染进程发起“提交文档”的消息
    - 渲染进程和网络进程建立传输数据的“管道”
    - 传输完成后，渲染进程发送“确认提交”的消息给浏览器进程
    - 浏览器及名称 更新界面（安全状态、前进后退历史状态、界面）
  - 渲染阶段
    

## 浏览上下文组
> (window.opener) 这一类具有相互连接关系的标签页成为 浏览上下文组\
> Chrome 浏览器会将浏览上下文组中属于同一站点的标签分配到同一个渲染进程中

### 浏览上下文
> 标签页所包含的内容: window对象/历史记录/滚动条位置等信息称为浏览上下文组
### 标签页之间的连接
> 同源站点 才可以通过  opener操作dom

- 通过 a标签  或者  window.open 打开的新标签页面
  - 新页面中的 window.opener 指向的就是 上个标签页
- 属于同一个浏览上下文组，且它们属于同一站点，浏览器会将它们分配到**同一个渲染进程**之中。
  - 可在对方标签页中执行脚本
    - 不过如果 A 标签页和 B 标签页属于同一站点，却不属于同源站点，那么你依然无法通过 opener 来操作父标签页中的 DOM，这依然会受到同源策略的限制。
    - 虽然根域名 geekbang.org 相同，但是域名却是不相同的，一个是 time.geekbang.org，一个是 www.geekbang.org， 因此浏览器判断它们不是同源的，

- Chrome 为什么使用同一站点划分渲染进程,而不是使用同源策略来划分渲染进程?
  - 同一站点,安全性已经有了保障
  - 同一站点,可以节省浏览器资源
#### 解除连接
- `<a rel="noopener noreferrer">`


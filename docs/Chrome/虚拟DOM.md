# 虚拟DOM

> 通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。

## 虚拟 DOM 到底要解决哪些事情
1. 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。
2. 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。
3. 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

### 虚拟dom如何运行
- 创建阶段
  - jsx + data => virtualDom => realDom =>渲染
- 更新阶段
  - 创建新的vdom => 比较两个树 => 把变化的地方一次性更新到 真实的dom树上 => 渲染

### React Fiber 更新机制
- 核心算法是 
  - 问题：执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿
- 新算法 Fiber reconciler
  - 协程的另外一个称呼就是 Fiber
  - 在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题

### 双缓存
> 可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，\
> 这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。


### MVC
> 我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。
[!基于 React 和 Redux 构建 MVC 模型](./res/%E5%9F%BA%E4%BA%8E%20React%20%E5%92%8C%20Redux%20%E6%9E%84%E5%BB%BA%20MVC%20%E6%A8%A1%E5%9E%8B.webp)

- 图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；
- 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；
- 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
- 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；
- 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
- DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。
#  系统的优化页面
> 页面优化，其实就是要让页面更快地显示和响应

## 加载阶段
> 主要因素有网络和 JavaScript 脚本
[加载阶段渲染流水线](./res/%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.webp)

- **关键资源**（阻塞网页首次渲染的资源）
  - 关键资源个数
  - 关键资源大小
  - 关键资源需要多少个RTT(Round Trip Time)
    - 1个 HTTP 数据包 在14kb左右， 一个0.1M 的页面 需要拆分为 8 个包传输，也就是 8个 RTT
    - 收到html数据后，预解析会快速扫描关键资源，可以认为js和css是同时发起请求，RTT只极短大的数据就可以了。
- **优化原则：减少关键资源个数、降低关键资源大小，降低关键资源RTT次数**
  - 通过资源内联 减少关键资源个数
  - 变成非关键资源
    - 如果js没有dom和css操作 可以使用 async 或 defer 
    - 如果css不是构建页面之前加载的，可通过 media属性来阻止显现
      - `<link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">`
  - 通过压缩、移除注释等方式减少关键资源大小、减少RTT次数和时长


## 交互阶段
> 主要因素是 JavaScript 脚本。\
> 渲染进程渲染帧的速度

[交互阶段渲染流水线](./res/%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF.webp)

- 重排（布局修改，触发重排）
- 重绘（只是修改了颜色一类的信息 触发重绘）
- 合成（通过 CSS 实现一些变形、渐变、动画等特效）
- **优化方案（让单个帧的生成速度变快）**
  - 减少js执行时间（霸占主线程）
    - 将一次执行的函数分解为多个任务
  - web workers（可以当作主线程之外的一个线程）
    - Web Workers 中是无法通过 JavaScript 来访问 DOM
    - 可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行
  - 避免强制同步布局
    - 正常情况下 重新计算样式和布局 **是在另外的任务中异步完成 避免当前的任务占用太长的主线程时间**
    - 所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。
      - 修改dom之后 获取offsetHeight 等信息，会导致立即执行布局操作
        - 在修改 DOM 之前查询相关值
  - 避免布局抖动
    - 所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作
    - 都是尽量不要在修改 DOM 结构时再去查询一些相关值。
  - 合理利用css合成动画
    - 合成动画是直接在合成线程上执行的，不受js阻塞影响
    - will-change
  - 避免频繁的垃圾回收
    - 如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。





- async 和 defer 差异
  - 使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。

- 白屏优化
  - 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏
    - 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载
    - 那么还可以尽量减少文件大小 压缩文件、移除一些不必要的
    - defer。
    - 拆分为多个不同用途的 CSS 文件

- 为什么css动画比js高效
  - js在来实现效果 会牵涉到整个渲染流水线，绘制效率低下
  - 如果经常要对某个元素做几何形状变换
    - 可以使用 will-change 来告诉渲染引擎
      - 这时渲染引擎会将该元素 独立一层，通过合成线程直接去处理变化，大大提高效率

```CSS
.box {
  will-change: transform, opacity;
}
```
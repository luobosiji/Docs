# 链表
> 不需要连续的内存空间，通过指针将一组零散的内存块串联。\
> 结点 + 下一个结点的地址 => 链表

### 单链表
> 只有一个方向

- 头结点（记录链表的基地址）
- 后继指针（记录下个结点地址的指针）
- 尾结点（最后一个结点，指向空地址null）
- 删除、插入 操作 为 O(1) 只需要考虑相邻结点指针改变
- 查找 为 O(n)

### 循环链表
> 循环链表的尾结点指针是指向链表的头结点。

### 双向链表
> 支持两个方向\
> 两个指针比较浪费存储空间，但是支持双向遍历，比较灵活

- 后继指针 next
- 前驱指针 prev
  - 在已经找到结点的情况下，插入 和删除的复杂度为O(1)
  - 优势再与往前插的时候 不用遍历查找
- **用空间换时间**
  - 内存充足时，追求代码执行速度
  - 内存紧缺时，用时间换空间
  - 缓存 实际上就是利用空间换时间的设计思想

- 循环链表 + 双向链表 => 双向循环链表

## 数组 VS 链表

- 内存空间连续性
  - 数组是连续的内存空间，可以借助**CPU缓存机制**，预读数组中的数据，访问效率更高
  - 链表在内存中是不连续的，对CPU缓存不友好
    - CPU缓存机制: cpu每次从内存中读取数据，并不是只读取特定访问地址，而是一个数据块（数组是连续的）
      - 意义：为了弥补内存访问速度过慢，CPU执行速度快的差异
- 内存空间大小
  - 数组是固定大小，
    - 太大 则要占用整块连续内存
    - 太小，不够用时要申请更大空间，并把原数组拷贝进去，非常费时
  - 链表没有大小限制，但是需要额外的空间存储指针。



## LRU缓存淘汰算法

- 常见的淘汰算法
  - 先进先出（FIFO First in, First out）
  - 最少使用策略（LFU Least Frequently Used）
  - 最近最少使用策略（LRU Least Recently Used）

- 思路： 维护一个有序单链表，尾部是最早访问的，当一个新数据被访问时，从链表头开始顺序遍历：
  1. 已存在链表中，则从原来位置删除，在插入到链表头部
  2. 不在链表中
    1. 此时缓存未满，将节点插入链表头部
    2. 此时缓存已满，则删除尾结点，在插入到头部
- 访问时都需要遍历链表，时间复杂度 O(n)
- 优化：**散列表**来记录每个数据的位置

## 思考题

- 如何判断一个字符串 是否是回文字符串？
  - 逆序，看是否相等
  - 快慢指针
- 单链表反转 206，141，21，19，876
- 链表中环的检测
- 两个有序链表合并
- 删除链表中倒数第n个节点
- 求链表中间节点


## 技巧
- 理解指针的含义
- 警惕指针丢失,注意操作顺序
- 利用**哨兵**简化实现难度
  - 哨兵：解决边界问题
    - 对于链表插入删除操作，需要对第一个节点和最后一个节点情况进行特殊处理。
    - 带头链表（任何时候，head指针指向哨兵节点）（head.next = null）
      - 不存储数据
    - 没有哨兵的为 不带头链表（head = null）
- 留意边界条件处理
  - 如果链表为空时，代码是否能正常工作？
  - 如果链表只包含一个结点时，代码是否能正常工作？
  - 如果链表只包含两个结点时，代码是否能正常工作？
  - 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
- 画图

